<story-context id=".bmad/bmm/workflows/4-implementation/story-context/template" v="1.0">
  <metadata>
    <epicId>4</epicId>
    <storyId>6</storyId>
    <title>Implement Snapshot Deduplication</title>
    <status>drafted</status>
    <generatedAt>2025-11-30</generatedAt>
    <generator>BMAD Story Context Workflow</generator>
    <sourceStoryPath>docs/sprint-artifacts/4-6-implement-snapshot-deduplication.md</sourceStoryPath>
  </metadata>

  <story>
    <asA>developer</asA>
    <iWant>duplicate snapshots prevented when appending new ones</iWant>
    <soThat>history doesn't contain redundant entries with identical timestamps</soThat>
    <tasks>
      <task id="1">Implement AppendSnapshot function (AC: 1, 2, 3)
        <subtask id="1.1">Add `AppendSnapshot(history []aggregator.Snapshot, snapshot aggregator.Snapshot, logger *slog.Logger) []aggregator.Snapshot` to `internal/storage/history.go`</subtask>
        <subtask id="1.2">Iterate through existing history to find matching timestamp</subtask>
        <subtask id="1.3">If matching timestamp found, replace snapshot in place and log debug message</subtask>
        <subtask id="1.4">If no matching timestamp, append new snapshot to slice</subtask>
        <subtask id="1.5">Sort result by timestamp ascending using `sort.Slice`</subtask>
        <subtask id="1.6">Add doc comment explaining deduplication behavior and sort guarantee</subtask>
      </task>
      <task id="2">Handle duplicate timestamp replacement (AC: 1, 4)
        <subtask id="2.1">When duplicate found, update slice element in place: `history[i] = snapshot`</subtask>
        <subtask id="2.2">Log debug message: "duplicate snapshot replaced" with timestamp attribute</subtask>
        <subtask id="2.3">Return history (length unchanged)</subtask>
      </task>
      <task id="3">Handle new timestamp append (AC: 2)
        <subtask id="3.1">When no duplicate found, append snapshot: `history = append(history, snapshot)`</subtask>
        <subtask id="3.2">Sort slice by timestamp ascending</subtask>
        <subtask id="3.3">Return extended history</subtask>
      </task>
      <task id="4">Write unit tests for AppendSnapshot (AC: 1-4)
        <subtask id="4.1">Test: empty history + new snapshot returns slice with 1 element</subtask>
        <subtask id="4.2">Test: existing history + duplicate timestamp replaces in place (length unchanged)</subtask>
        <subtask id="4.3">Test: existing history + new timestamp appends (length increases by 1)</subtask>
        <subtask id="4.4">Test: result is always sorted by timestamp ascending</subtask>
        <subtask id="4.5">Test: multiple appends maintain sorted order</subtask>
        <subtask id="4.6">Test: verify debug log emitted for duplicate replacement</subtask>
      </task>
      <task id="5">Verification (AC: all)
        <subtask id="5.1">Run `go build ./...` and verify success</subtask>
        <subtask id="5.2">Run `go test ./internal/storage/...` and verify all pass</subtask>
        <subtask id="5.3">Run `make lint` and verify no errors</subtask>
      </task>
    </tasks>
  </story>

  <acceptanceCriteria>
    <criterion id="AC-1">Given existing history with snapshot at timestamp 1700000000 When `AppendSnapshot(history, newSnapshot)` is called with same timestamp Then the new snapshot replaces the existing one (update in place) And history length remains unchanged</criterion>
    <criterion id="AC-2">Given existing history with snapshots at [1700000000, 1700003600] When `AppendSnapshot` is called with timestamp 1700007200 Then new snapshot is appended And history length increases by 1</criterion>
    <criterion id="AC-3">Given history after any append operation When history is returned Then snapshots are sorted by timestamp ascending (oldest first)</criterion>
    <criterion id="AC-4">Given `AppendSnapshot` is called with a duplicate timestamp When replacement occurs Then debug log: "duplicate snapshot replaced" with `timestamp` attribute</criterion>
  </acceptanceCriteria>

  <artifacts>
    <docs>
      <doc>
        <path>docs/prd.md</path>
        <title>Product Requirements Document</title>
        <section>FR32</section>
        <snippet>System deduplicates snapshots with identical timestamps. Historical data management requires maintaining snapshots over time without redundant entries.</snippet>
      </doc>
      <doc>
        <path>docs/epics/epic-4-state-history-management.md</path>
        <title>Epic 4: State and History Management</title>
        <section>Story 4.6</section>
        <snippet>Implements snapshot deduplication: AppendSnapshot(history, newSnapshot) replaces existing snapshot with same timestamp, sorts by timestamp ascending.</snippet>
      </doc>
      <doc>
        <path>docs/sprint-artifacts/tech-spec-epic-4.md</path>
        <title>Epic 4 Technical Specification</title>
        <section>AC-4.6, History Append Flow</section>
        <snippet>AppendSnapshot replaces existing snapshot with matching timestamp, appends if unique, returns sorted history. Deduplication by timestamp comparison, maintain sorted invariant.</snippet>
      </doc>
      <doc>
        <path>docs/architecture/data-architecture.md</path>
        <title>Data Architecture</title>
        <section>Output Models</section>
        <snippet>FullOutput includes Historical []Snapshot for time-series tracking. Snapshot struct contains Timestamp, Date, TVS, TVSByChain, ProtocolCount, ChainCount.</snippet>
      </doc>
      <doc>
        <path>docs/architecture/implementation-patterns.md</path>
        <title>Implementation Patterns</title>
        <section>Atomic File Writes, Context Propagation</section>
        <snippet>Use Go idioms: explicit dependencies, context propagation for I/O, sort.Slice for ordering. Follow ADR-003 for error returns, ADR-004 for slog logging.</snippet>
      </doc>
      <doc>
        <path>docs/architecture/architecture-decision-records-adrs.md</path>
        <title>Architecture Decision Records</title>
        <section>ADR-003, ADR-004</section>
        <snippet>ADR-003: Explicit error returns over exceptions. ADR-004: Structured logging with slog, JSON output for operations.</snippet>
      </doc>
      <doc>
        <path>docs/architecture/testing-strategy.md</path>
        <title>Testing Strategy</title>
        <section>Test Organization</section>
        <snippet>Use table-driven tests, co-located *_test.go files. High coverage for business-critical aggregation logic. Error handling paths must be tested.</snippet>
      </doc>
      <doc>
        <path>docs/architecture/project-structure.md</path>
        <title>Project Structure</title>
        <section>internal/storage/</section>
        <snippet>Storage package includes history.go for historical snapshot management. All internal packages are Go compiler enforced private.</snippet>
      </doc>
      <doc>
        <path>docs/sprint-artifacts/4-5-implement-history-loading-from-output-file.md</path>
        <title>Story 4.5: History Loading (Completed)</title>
        <section>Dev Agent Record, Patterns to Reuse</section>
        <snippet>Patterns: Table-driven tests with fixtures; slog.Default() fallback for nil logger; history functions keep timestamps sorted ascending; reuse aggregator.Snapshot.</snippet>
      </doc>
    </docs>
    <code>
      <artifact>
        <path>internal/storage/history.go</path>
        <kind>service</kind>
        <symbol>CreateSnapshot, LoadFromOutput, outputHistoryExtract</symbol>
        <lines>1-88</lines>
        <reason>Target file for adding AppendSnapshot function. Contains existing CreateSnapshot and LoadFromOutput functions that this story builds upon.</reason>
      </artifact>
      <artifact>
        <path>internal/storage/history_test.go</path>
        <kind>test</kind>
        <symbol>TestCreateSnapshot_*, TestLoadFromOutput_*</symbol>
        <lines>1-223</lines>
        <reason>Test file for history functions. Add AppendSnapshot tests following established table-driven patterns.</reason>
      </artifact>
      <artifact>
        <path>internal/aggregator/models.go</path>
        <kind>model</kind>
        <symbol>Snapshot</symbol>
        <lines>41-48</lines>
        <reason>Snapshot struct definition: Timestamp (int64), Date (string), TVS (float64), TVSByChain (map[string]float64), ProtocolCount (int), ChainCount (int).</reason>
      </artifact>
      <artifact>
        <path>internal/aggregator/models.go</path>
        <kind>model</kind>
        <symbol>AggregationResult</symbol>
        <lines>60-72</lines>
        <reason>AggregationResult struct used as input to CreateSnapshot. Contains TotalTVS, TotalProtocols, ActiveChains, ChainBreakdown, Timestamp fields.</reason>
      </artifact>
      <artifact>
        <path>internal/storage/state_test.go</path>
        <kind>test helper</kind>
        <symbol>newTestLogger</symbol>
        <lines>14-16</lines>
        <reason>Test helper function creating slog.Logger with JSON handler for testing. Reuse for AppendSnapshot tests to verify logging.</reason>
      </artifact>
      <artifact>
        <path>internal/storage/testdata/output_with_history.json</path>
        <kind>fixture</kind>
        <symbol>N/A</symbol>
        <lines>N/A</lines>
        <reason>Test fixture with 3 snapshots at timestamps 1700000000, 1700003600, 1700007200. Reference for expected data format.</reason>
      </artifact>
    </code>
    <dependencies>
      <go>
        <module>github.com/switchboard-xyz/defillama-extract</module>
        <version>go 1.24.0</version>
        <toolchain>go1.24.10</toolchain>
        <packages>
          <package name="golang.org/x/sync" version="v0.18.0" usage="errgroup for parallel operations" />
          <package name="gopkg.in/yaml.v3" version="v3.0.1" usage="YAML config parsing" />
        </packages>
        <stdlib>
          <package name="encoding/json" usage="JSON marshaling/unmarshaling" />
          <package name="log/slog" usage="Structured logging (ADR-004)" />
          <package name="os" usage="File operations" />
          <package name="sort" usage="Sorting snapshots by timestamp" />
          <package name="time" usage="Date formatting from Unix timestamp" />
        </stdlib>
      </go>
    </dependencies>
  </artifacts>

  <constraints>
    <constraint source="ADR-003">Use explicit error returns over exceptions. Errors are values in Go.</constraint>
    <constraint source="ADR-004">Use log/slog for structured logging. Debug level for operational details, Warn for degraded states.</constraint>
    <constraint source="ADR-005">Minimal external dependencies. This story uses only Go standard library packages.</constraint>
    <constraint source="tech-spec-epic-4">No automatic pruning logic (FR33). MVP retains all snapshots.</constraint>
    <constraint source="project-structure">All changes scoped to internal/storage/ package per project structure.</constraint>
    <constraint source="story-4.5-learnings">Follow patterns: slog.Default() fallback for nil logger; keep timestamps sorted ascending; reuse aggregator.Snapshot type.</constraint>
  </constraints>

  <interfaces>
    <interface>
      <name>AppendSnapshot</name>
      <kind>function</kind>
      <signature>func AppendSnapshot(history []aggregator.Snapshot, snapshot aggregator.Snapshot, logger *slog.Logger) []aggregator.Snapshot</signature>
      <path>internal/storage/history.go</path>
    </interface>
    <interface>
      <name>aggregator.Snapshot</name>
      <kind>struct</kind>
      <signature>type Snapshot struct { Timestamp int64; Date string; TVS float64; TVSByChain map[string]float64; ProtocolCount int; ChainCount int }</signature>
      <path>internal/aggregator/models.go:41-48</path>
    </interface>
    <interface>
      <name>CreateSnapshot</name>
      <kind>function</kind>
      <signature>func CreateSnapshot(result *aggregator.AggregationResult) aggregator.Snapshot</signature>
      <path>internal/storage/history.go:22-44</path>
    </interface>
    <interface>
      <name>LoadFromOutput</name>
      <kind>function</kind>
      <signature>func LoadFromOutput(outputPath string, logger *slog.Logger) ([]aggregator.Snapshot, error)</signature>
      <path>internal/storage/history.go:50-88</path>
    </interface>
  </interfaces>

  <tests>
    <standards>Go table-driven tests following project testing-strategy.md. Co-located *_test.go files. Use bytes.Buffer with slog.NewJSONHandler for log verification. High coverage for business-critical logic. Test all error paths and edge cases.</standards>
    <locations>
      <location>internal/storage/history_test.go</location>
      <location>internal/storage/testdata/</location>
    </locations>
    <ideas>
      <idea acRef="AC-1">TestAppendSnapshot_DuplicateTimestampReplacesInPlace: history with timestamp 1700000000, append snapshot with same timestamp, verify length unchanged, data replaced</idea>
      <idea acRef="AC-2">TestAppendSnapshot_NewTimestampAppends: history with [1700000000, 1700003600], append timestamp 1700007200, verify length increases by 1</idea>
      <idea acRef="AC-3">TestAppendSnapshot_ResultAlwaysSorted: append out-of-order timestamps, verify result sorted ascending</idea>
      <idea acRef="AC-4">TestAppendSnapshot_LogsOnDuplicateReplacement: use bytes.Buffer logger, verify debug log contains "duplicate snapshot replaced" with timestamp attribute</idea>
      <idea acRef="AC-1,2">TestAppendSnapshot_EmptyHistory: append to empty slice, verify returns slice with 1 element</idea>
      <idea acRef="AC-3">TestAppendSnapshot_MultipleAppendsPreserveSortOrder: sequential appends with various timestamps, verify always sorted</idea>
      <idea acRef="AC-1">TestAppendSnapshot_NilLoggerUsesDefault: pass nil logger, verify no panic, function works correctly</idea>
    </ideas>
  </tests>
</story-context>
