<story-context id=".bmad/bmm/workflows/4-implementation/story-context/template" v="1.0">
  <metadata>
    <epicId>4</epicId>
    <storyId>3</storyId>
    <title>Implement Atomic State File Updates</title>
    <status>ready-for-dev</status>
    <generatedAt>2025-11-30</generatedAt>
    <generator>BMAD Story Context Workflow</generator>
    <sourceStoryPath>docs/sprint-artifacts/4-3-implement-atomic-state-file-updates.md</sourceStoryPath>
  </metadata>

  <story>
    <asA>developer</asA>
    <iWant>state updates written atomically</iWant>
    <soThat>interrupted writes don't corrupt the state file</soThat>
    <tasks>
      <task id="1" ac="5">Implement WriteAtomic utility function
        <subtask id="1.1">Create internal/storage/writer.go with WriteAtomic(path string, data []byte, perm os.FileMode) error</subtask>
        <subtask id="1.2">Use os.CreateTemp(dir, ".tmp-*") to create temp file in same directory as target</subtask>
        <subtask id="1.3">Write data to temp file with tmpFile.Write(data)</subtask>
        <subtask id="1.4">Call tmpFile.Sync() to ensure data is flushed to disk</subtask>
        <subtask id="1.5">Close temp file</subtask>
        <subtask id="1.6">Set permissions with os.Chmod(tmpPath, perm)</subtask>
        <subtask id="1.7">Atomically rename with os.Rename(tmpPath, path)</subtask>
        <subtask id="1.8">Use defer with cleanup flag to ensure temp file cleanup on error</subtask>
        <subtask id="1.9">Add doc comment explaining atomic write guarantees and POSIX limitations</subtask>
      </task>
      <task id="2" ac="1,2,4">Implement SaveState method on StateManager
        <subtask id="2.1">Add func (sm *StateManager) SaveState(state *State) error to internal/storage/state.go</subtask>
        <subtask id="2.2">Marshal state to JSON with indentation (json.MarshalIndent)</subtask>
        <subtask id="2.3">Ensure output directory exists: os.MkdirAll(sm.outputDir, 0755)</subtask>
        <subtask id="2.4">Call WriteAtomic(sm.stateFile, data, 0644)</subtask>
        <subtask id="2.5">Log info "state saved" with timestamp, protocol_count, tvs attributes on success</subtask>
        <subtask id="2.6">Return wrapped error with context on failure</subtask>
      </task>
      <task id="3" ac="3">Implement error handling and cleanup
        <subtask id="3.1">In WriteAtomic: use defer with cleanupNeeded flag to remove temp file on error paths</subtask>
        <subtask id="3.2">In WriteAtomic: wrap errors with context (e.g., "create temp file", "write data", "sync", "rename")</subtask>
        <subtask id="3.3">Verify original file untouched when write fails (atomic rename only happens on success)</subtask>
      </task>
      <task id="4" ac="3,5">Write unit tests for WriteAtomic
        <subtask id="4.1">Create internal/storage/writer_test.go</subtask>
        <subtask id="4.2">Test: successful write creates file with correct content</subtask>
        <subtask id="4.3">Test: write to new directory creates directory</subtask>
        <subtask id="4.4">Test: correct permissions applied to final file</subtask>
        <subtask id="4.5">Test: temp file cleaned up on write error (simulate with read-only dir)</subtask>
        <subtask id="4.6">Test: original file preserved on rename error (if feasible to simulate)</subtask>
      </task>
      <task id="5" ac="1,2,4">Write unit tests for SaveState
        <subtask id="5.1">Add tests to internal/storage/state_test.go</subtask>
        <subtask id="5.2">Test: SaveState creates state.json with correct JSON content</subtask>
        <subtask id="5.3">Test: SaveState creates directory if not exists</subtask>
        <subtask id="5.4">Test: SaveState logs "state saved" with correct attributes</subtask>
        <subtask id="5.5">Test: SaveState returns error on write failure</subtask>
      </task>
      <task id="6" ac="all">Verification
        <subtask id="6.1">Run go build ./... and verify success</subtask>
        <subtask id="6.2">Run go test ./internal/storage/... and verify all pass</subtask>
        <subtask id="6.3">Run make lint and verify no errors</subtask>
      </task>
    </tasks>
  </story>

  <acceptanceCriteria>
    <criterion id="1">Given a valid *State struct When SaveState(state *State) is called Then state is written to a temp file first (.tmp-* pattern in same directory) And temp file is renamed to state.json atomically</criterion>
    <criterion id="2">Given the output directory doesn't exist When SaveState is called Then the directory is created with 0755 permissions And state file is written successfully</criterion>
    <criterion id="3">Given a write failure (disk full, permissions) When SaveState fails Then an error is returned with descriptive message And any temp file is cleaned up And original state file (if exists) is preserved</criterion>
    <criterion id="4">Given successful state save When operation completes Then info log: "state saved" with attributes: timestamp, protocol_count, tvs</criterion>
    <criterion id="5">Given a WriteAtomic(path string, data []byte, perm os.FileMode) utility function When called with valid inputs Then writes to temp file, syncs, and atomically renames to target And can be reused for other atomic file operations</criterion>
  </acceptanceCriteria>

  <artifacts>
    <docs>
      <doc>
        <path>docs/sprint-artifacts/tech-spec-epic-4.md</path>
        <title>Epic Technical Specification: State and History Management</title>
        <section>AC-4.3: Atomic State File Updates</section>
        <snippet>SaveState(state) writes to temp file first, temp file renamed to state.json atomically, directory created if doesn't exist, temp file cleaned up on any error, original state preserved on write failure, success logged with timestamp, protocol_count, tvs.</snippet>
      </doc>
      <doc>
        <path>docs/architecture/implementation-patterns.md</path>
        <title>Implementation Patterns</title>
        <section>Atomic File Writes</section>
        <snippet>Never write directly to target file. Write to temp file, then atomic rename. os.Rename is atomic on POSIX systems.</snippet>
      </doc>
      <doc>
        <path>docs/architecture/architecture-decision-records-adrs.md</path>
        <title>Architecture Decision Records</title>
        <section>ADR-002: Atomic File Writes</section>
        <snippet>Write to temp file, then atomic rename. os.Rename is atomic on POSIX systems. Readers always see complete previous version or complete new version.</snippet>
      </doc>
      <doc>
        <path>docs/architecture/architecture-decision-records-adrs.md</path>
        <title>Architecture Decision Records</title>
        <section>ADR-003: Explicit Error Returns Over Exceptions</section>
        <snippet>Return errors explicitly, wrap with context, use sentinel errors for expected conditions. Error wrapping provides stack context.</snippet>
      </doc>
      <doc>
        <path>docs/architecture/architecture-decision-records-adrs.md</path>
        <title>Architecture Decision Records</title>
        <section>ADR-004: Structured Logging with slog</section>
        <snippet>Use log/slog (stdlib) with JSON output. Structured fields enable log aggregation. Text mode available for development.</snippet>
      </doc>
      <doc>
        <path>docs/architecture/testing-strategy.md</path>
        <title>Testing Strategy</title>
        <section>Test Organization</section>
        <snippet>Unit tests in *_test.go co-located. Table-driven tests for multiple inputs/outputs. Test fixtures in testdata/ directory.</snippet>
      </doc>
      <doc>
        <path>docs/sprint-artifacts/4-2-implement-state-comparison-for-skip-logic.md</path>
        <title>Story 4.2: Implement State Comparison for Skip Logic</title>
        <section>Dev Agent Record</section>
        <snippet>Previous story (done) established StateManager method pattern, structured logging with slog, table-driven tests. Use same patterns for SaveState.</snippet>
      </doc>
    </docs>

    <code>
      <artifact>
        <path>internal/storage/state.go</path>
        <kind>service</kind>
        <symbol>StateManager</symbol>
        <lines>28-47</lines>
        <reason>Existing StateManager struct and NewStateManager constructor. SaveState method will be added to this struct.</reason>
      </artifact>
      <artifact>
        <path>internal/storage/state.go</path>
        <kind>model</kind>
        <symbol>State</symbol>
        <lines>15-24</lines>
        <reason>State struct that will be serialized by SaveState. Contains OracleName, LastUpdated, LastProtocolCount, LastTVS fields.</reason>
      </artifact>
      <artifact>
        <path>internal/storage/state.go</path>
        <kind>method</kind>
        <symbol>LoadState</symbol>
        <lines>52-78</lines>
        <reason>Existing LoadState method shows logging patterns and error handling style to follow for SaveState.</reason>
      </artifact>
      <artifact>
        <path>internal/storage/state.go</path>
        <kind>method</kind>
        <symbol>ShouldProcess</symbol>
        <lines>85-111</lines>
        <reason>Existing ShouldProcess shows slog usage with Debug/Info/Warn levels and attributes.</reason>
      </artifact>
      <artifact>
        <path>internal/storage/state_test.go</path>
        <kind>test</kind>
        <symbol>newTestLogger</symbol>
        <lines>14-16</lines>
        <reason>Test logger helper for capturing log output. Reuse for SaveState tests.</reason>
      </artifact>
      <artifact>
        <path>internal/storage/state_test.go</path>
        <kind>test</kind>
        <symbol>TestStateManager_ShouldProcess</symbol>
        <lines>152-252</lines>
        <reason>Table-driven test pattern with log verification. Use same pattern for SaveState tests.</reason>
      </artifact>
      <artifact>
        <path>internal/storage/testdata/valid_state.json</path>
        <kind>fixture</kind>
        <symbol>valid_state</symbol>
        <lines>all</lines>
        <reason>Test fixture with valid State JSON. Reference for expected SaveState output format.</reason>
      </artifact>
      <artifact>
        <path>internal/storage/doc.go</path>
        <kind>documentation</kind>
        <symbol>package storage</symbol>
        <lines>all</lines>
        <reason>Package documentation. May need update after adding writer.go.</reason>
      </artifact>
    </code>

    <dependencies>
      <ecosystem name="go">
        <package name="go" version="1.24.0">Go runtime and standard library</package>
        <package name="golang.org/x/sync" version="v0.18.0">Sync primitives including errgroup (not used in this story)</package>
        <package name="gopkg.in/yaml.v3" version="v3.0.1">YAML parsing for config (not used in this story)</package>
      </ecosystem>
      <stdlib>
        <package name="encoding/json">JSON marshaling for State struct</package>
        <package name="fmt">Error wrapping with fmt.Errorf</package>
        <package name="log/slog">Structured logging per ADR-004</package>
        <package name="os">File I/O: CreateTemp, WriteFile, Rename, MkdirAll, Chmod, Remove</package>
        <package name="path/filepath">Path manipulation: Dir, Join</package>
      </stdlib>
    </dependencies>
  </artifacts>

  <constraints>
    <constraint source="ADR-002">Use temp file + atomic rename pattern. Never write directly to target file.</constraint>
    <constraint source="ADR-003">Return errors explicitly with context wrapping using fmt.Errorf and %w verb.</constraint>
    <constraint source="ADR-004">Use log/slog for structured logging. Info level for successful save with timestamp, protocol_count, tvs attributes.</constraint>
    <constraint source="ADR-005">No external dependencies. Use Go standard library only for this story.</constraint>
    <constraint source="tech-spec">WriteAtomic must: create temp file with .tmp-* pattern, write data, sync, close, chmod, rename. Cleanup temp on any error.</constraint>
    <constraint source="tech-spec">File permissions: directories 0755, state file 0644.</constraint>
    <constraint source="tech-spec">State operations must complete within 100ms under normal conditions.</constraint>
    <constraint source="project-structure">New file: internal/storage/writer.go. Extend: internal/storage/state.go with SaveState method.</constraint>
  </constraints>

  <interfaces>
    <interface>
      <name>WriteAtomic</name>
      <kind>function</kind>
      <signature>func WriteAtomic(path string, data []byte, perm os.FileMode) error</signature>
      <path>internal/storage/writer.go</path>
    </interface>
    <interface>
      <name>StateManager.SaveState</name>
      <kind>method</kind>
      <signature>func (sm *StateManager) SaveState(state *State) error</signature>
      <path>internal/storage/state.go</path>
    </interface>
    <interface>
      <name>StateManager (existing)</name>
      <kind>struct</kind>
      <signature>type StateManager struct { outputDir, stateFile, outputFile string; logger *slog.Logger }</signature>
      <path>internal/storage/state.go:28-33</path>
    </interface>
    <interface>
      <name>State (existing)</name>
      <kind>struct</kind>
      <signature>type State struct { OracleName string; LastUpdated int64; LastUpdatedISO string; LastProtocolCount int; LastTVS float64; SnapshotCount int; OldestSnapshot, NewestSnapshot int64 }</signature>
      <path>internal/storage/state.go:15-24</path>
    </interface>
  </interfaces>

  <tests>
    <standards>Go table-driven tests with t.TempDir() for isolated file system tests. Use newTestLogger helper from state_test.go to capture log output. Verify log level, message, and attributes for SaveState success. Test both success and error paths. Coverage target: 90%+ for state.go and writer.go.</standards>
    <locations>
      <location>internal/storage/writer_test.go (new)</location>
      <location>internal/storage/state_test.go (extend)</location>
      <location>internal/storage/testdata/ (existing fixtures)</location>
    </locations>
    <ideas>
      <idea ac="1,5">TestWriteAtomic_Success: Write data to new file, verify content matches, verify no temp files left</idea>
      <idea ac="2">TestWriteAtomic_CreatesDirectory: Write to non-existent directory, verify directory created with 0755</idea>
      <idea ac="5">TestWriteAtomic_Permissions: Write file, verify permissions are 0644</idea>
      <idea ac="3">TestWriteAtomic_CleanupOnError: Force error (read-only dir), verify no temp files remain</idea>
      <idea ac="3">TestWriteAtomic_PreservesOriginal: Write to existing file, force rename error, verify original unchanged</idea>
      <idea ac="1">TestSaveState_Success: Save valid state, verify JSON content matches expected structure</idea>
      <idea ac="2">TestSaveState_CreatesDirectory: Save to non-existent outputDir, verify directory and file created</idea>
      <idea ac="4">TestSaveState_LogsSuccess: Save state, capture log, verify Info level with timestamp/protocol_count/tvs</idea>
      <idea ac="3">TestSaveState_ErrorOnWriteFailure: Force write error, verify error returned with context</idea>
      <idea ac="1">TestSaveState_JSONRoundTrip: Save state, LoadState, verify fields match</idea>
    </ideas>
  </tests>
</story-context>
